(lines-aux 50 (s/split s #"\s") '())
(lines 20 s)
(doc throws)
(/ .25 .65)
(/ 0.25 0.65)
)
(use 'figwheel-sidecar.repl-api)
(use 'clojure.contrib.math)
(* 4 32)
(doc reduce)
(doc update)
(update {:m 2} :m (partial + 1))
(update {:m 2} :n (partial + 1))
(update {:m 2} :m + 1)
(update {:m 2} :m (fn [x] (if x (+ x 1) 1) 
)
(update {:m 2} :m (fn [x] (if x (+ x 1) 1))) 
(update {:m 2} :n (fn [x] (if x (+ x 1) 1))) 
(update {} :n (fn [x] (if x (+ x 1) 1))) 
(update {} :n + 1 #_(fn [x] (if x (+ x 1) 1))) 
(doc update-in)
(update-in {} [:n] + 1) 
(update-in {:n 2} [:n] + 1) 
(def xs [10 20 20 10 10 30 50 10 20])
xs
(reduce (fn [acc xs] acc) xs {})
(reduce (fn [x acc] acc) xs {})
(reduce (fn [x acc] x) xs {})
(doc reduce)
(reduce (fn [x acc] x) {} xs)
(reduce (fn [acc x] x) {} xs)
(frequencies xs)
(->> (frequencies xs) (filter (fn [x] (> x 1))))
(->> (frequencies xs) (filter (fn [[k v]] (> v 1))))
(/ 3 2)
(int (/ 3 2))
(int (/ 4 2))
(->> (frequencies xs) (filter (fn [[k v]] (> v 1))) (map (fn [[k v]] (int (/ v 2)))))
(->> (frequencies xs) (filter (fn [[k v]] (> v 1))) (map (fn [[k v]] (int (/ v 2)))) sum)
(->> (frequencies xs) (filter (fn [[k v]] (> v 1))) (map (fn [[k v]] (int (/ v 2)))) (reduce +))
